#!/usr/bin/env python
# Copyright 2012 Kodi Arfer
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish, dis-
# tribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the fol-
# lowing conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
# ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
# SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS

import argparse # Hence, Python 2.7 is required.
import inspect
import datetime, calendar
import json
import boto.mturk.connection, boto.mturk.price, boto.mturk.question, boto.mturk.qualification

interactive = False
con = None
mturk_website = None

# --------------------------------------------------
# Subroutines
# --------------------------------------------------

def unjson(path):
    with open(path) as o:
        return json.load(o)

def init(sandbox = False):
    global con, mturk_website
    mturk_website = 'workersandbox.mturk.com' if sandbox else 'mturk.com'
    con = boto.mturk.connection.MTurkConnection(
        host = 'mechanicalturk.sandbox.amazonaws.com' if sandbox else 'mechanicalturk.amazonaws.com')

time_units = dict(s = 1, min = 60, hr = 60 * 60, d = 24 * 60 * 60)
def parse_duration(s):
    '''Parses durations like "2 d", "48 hr", "2880 min",
"172800 s", or "172800".'''
    x = s.split()
    return int(x[0]) * time_units['s' if len(x) == 1 else x[1]]
def display_duration(n):
    for unit, m in sorted(time_units.items(), key = lambda x: -x[1]):
        if n % m == 0:
            return '{} {}'.format(n / m, unit)

def parse_qualification(s):
    '''Parses qualifications like "PercentAssignmentsApproved > 90" and "Locale == US".'''
    name, comparator, value = s.split()
    f = dict(
        PercentAssignmentsApproved = boto.mturk.qualification.PercentAssignmentsApprovedRequirement,
        Locale = boto.mturk.qualification.LocaleRequirement)[name]
    comparator = {v : k for k, v in dict(
        LessThan = '<', LessThanOrEqualTo = '<=',
        GreaterThan = '>', GreaterThanOrEqualTo = '>=',
        EqualTo = '==', NotEqualTo = '!=').items()}[comparator]
    return f(comparator, value, required_to_preview = False)

def preview_url(hit):
    return 'https://{}/mturk/preview?groupId={}'.format(
        mturk_website, hit.HITTypeId)

def parse_timestamp(s):
    '''Takes a timestamp like "2012-11-24T16:34:41Z".

Returns a datetime object in the local time zone.'''
    return datetime.datetime.fromtimestamp(
        calendar.timegm(
        datetime.datetime.strptime(s, '%Y-%m-%dT%H:%M:%SZ').timetuple()))

def display_datetime(dt):
    return dt.strftime('%e %b %Y, %l:%M %P')

def display_hit(hit):
    et = parse_timestamp(hit.Expiration)
    return '\n'.join([
        '{} ({}, {}, {})'.format(
            hit.Title,
            hit.FormattedPrice,
            display_duration(int(hit.AssignmentDurationInSeconds)),
            hit.HITStatus),
        'HIT ID: ' + hit.HITId,
        'Type ID: ' + hit.HITTypeId,
        'Group ID: ' + hit.HITGroupId,
        'Preview: ' + preview_url(hit),
        'Created {}   {}'.format(
            display_datetime(parse_timestamp(hit.CreationTime)),
            'Expired' if et <= datetime.datetime.now() else
                'Expires ' + display_datetime(et)),
        'Assignments: {} -- {} avail, {} pending, {} reviewable, {} reviewed'.format(
            hit.MaxAssignments,
            hit.NumberOfAssignmentsAvailable,
            hit.NumberOfAssignmentsPending,
            int(hit.MaxAssignments) - (int(hit.NumberOfAssignmentsAvailable) + int(hit.NumberOfAssignmentsPending) + int(hit.NumberOfAssignmentsCompleted)),
            hit.NumberOfAssignmentsCompleted)
            if hasattr(hit, 'NumberOfAssignmentsAvailable')
            else 'Assignments: {} total'.format(hit.MaxAssignments)
            # For some reason, SearchHITs includes the
            # NumberOfAssignmentsFoobar fields but GetHIT doesn't.
        ]) + '\n'

def digest_assignment(a):
    return dict(
        answers = {str(x.qid): str(x.fields[0]) for x in a.answers[0]},
        **{k: str(getattr(a, k)) for k in (
            'AcceptTime', 'SubmitTime',
            'HITId', 'AssignmentId', 'WorkerId',
            'AssignmentStatus')})

# --------------------------------------------------
# Commands
# --------------------------------------------------

def get_balance():
    return con.get_account_balance()

def show_hit(hit):
    return display_hit(con.get_hit(hit)[0])

def list_hits():
    'Lists your 10 most recently created HITs, with the most recent last.'
    return '\n'.join(reversed(map(display_hit, con.search_hits(
        sort_by = 'CreationTime',
        sort_direction = 'Descending',
        page_size = 10))))

def make_hit(title, description, keywords, reward, question_url, question_frame_height, duration, assignments, approval_delay, lifetime, qualifications = []):
    r = con.create_hit(
        title = title,
        description = description,
        keywords = con.get_keywords_as_string(keywords),
        reward = con.get_price_as_price(reward),
        question = boto.mturk.question.ExternalQuestion(
            question_url,
            question_frame_height),
        duration = parse_duration(duration),
        qualifications = boto.mturk.qualification.Qualifications(
            map(parse_qualification, qualifications)),
        max_assignments = assignments,
        approval_delay = parse_duration(approval_delay),
        lifetime = parse_duration(lifetime))
    if interactive:
        print 'HIT ID:', r[0].HITId
        print 'Preview:', preview_url(r[0])
    else:
        return r[0]

def extend_hit(hit, assignments_increment = None, expiration_increment = None):
    con.extend_hit(hit, assignments_increment, expiration_increment)

def expire_hit(hit):
    con.expire_hit(hit)

def delete_hit(hit):
    '''Deletes a HIT using DisableHIT.

Unreviewed assignments get automatically approved. Unsubmitted
assignments get automatically approved upon submission.

The API docs say DisableHIT doesn't work with Reviewable HITs,
but apparently, it does.'''
    con.disable_hit(hit)

def list_assignments(hit, only_reviewable = False):
    assignments = map(digest_assignment, con.get_assignments(
        hit_id = hit,
        page_size = 100,
        status = 'Submitted' if only_reviewable else None))
    if interactive:
        print json.dumps(assignments, sort_keys = True, indent = 4)
        print ' '.join([a['AssignmentId'] for a in assignments])
        print ' '.join([a['WorkerId'] + ',' + a['AssignmentId'] for a in assignments])
    else:
        return assignments

def grant_bonus(message, amount, pairs):
    for worker, assignment in pairs:
        con.grant_bonus(worker, assignment, con.get_price_as_price(amount), message)
        if interactive: print 'Bonused', worker

def approve_assignments(message, assignments):
    for a in assignments:
        con.approve_assignment(a, message)
        if interactive: print 'Approved', a

def reject_assignments(message, assignments):
    for a in assignments:
        con.reject_assignment(a, message)
        if interactive: print 'Rejected', a

def unreject_assignments(message, assignments):
    for a in assignments:
        con.approve_rejected_assignment(a, message)
        if interactive: print 'Unrejected', a

# --------------------------------------------------
# Mainline code
# --------------------------------------------------

if __name__ == '__main__':

    interactive = True

    parser = argparse.ArgumentParser()
    subs = parser.add_subparsers()

    parser.add_argument('-P', '--production',
        dest = 'sandbox', action = 'store_false', default = True,
        help = 'use the production site (default: use the sandbox)')

    sub = subs.add_parser('bal',
        help = 'display your prepaid balance')
    sub.set_defaults(f = get_balance, a = lambda args: [])

    sub = subs.add_parser('hit',
        help = 'get information about a HIT')
    sub.add_argument('hit',
        help = 'ID of the HIT to show')
    sub.set_defaults(f = show_hit, a = lambda args:
        [args.hit])

    sub = subs.add_parser('hits',
        help = 'list all your HITS')
    sub.set_defaults(f = list_hits, a = lambda args: [])

    sub = subs.add_parser('new',
        help = 'create a new HIT')
    sub.add_argument('json_path',
        help = 'path to JSON configuration file for the HIT')
    sub.add_argument('-u', '--question-url', dest = 'question_url',
        metavar = 'URL',
        help = 'URL for the external question')
    sub.add_argument('-a', '--assignments', dest = 'assignments',
        type = int, metavar = 'N',
        help = 'number of assignments')
    sub.add_argument('-r', '--reward', dest = 'reward',
        type = float, metavar = 'PRICE',
        help = 'reward amount')
    sub.set_defaults(f = make_hit, a = lambda args: dict(
        unjson(args.json_path).items() + [(k, getattr(args, k))
            for k in ('question_url', 'assignments', 'reward')
            if getattr(args, k) is not None]))

    sub = subs.add_parser('extend',
        help = 'add assignments or time to a HIT')
    sub.add_argument('hit',
        help = 'ID of the HIT to extend')
    sub.add_argument('-a', '--assignments', dest = 'assignments',
        metavar = 'N', type = int,
        help = 'number of assignments to add')
    sub.add_argument('-t', '--time', dest = 'time',
        metavar = 'T',
        help = 'amount of time to add to the expiration date')
    sub.set_defaults(f = extend_hit, a = lambda args:
        [args.hit, args.assignments, args.time and parse_duration(args.time)])

    sub = subs.add_parser('rm',
        help = 'delete a HIT')
    sub.add_argument('hit',
        help = 'ID of the HIT to delete')
    sub.set_defaults(f = delete_hit, a = lambda args:
        [args.hit])

    sub = subs.add_parser('expire',
        help = 'force a HIT to expire without deleting it')
    sub.add_argument('hit',
        help = 'ID of the HIT to expire')
    sub.set_defaults(f = expire_hit, a = lambda args:
        [args.hit])

    sub = subs.add_parser('as',
        help = "list a HIT's submitted assignments")
    sub.add_argument('hit',
        help = 'ID of the HIT to get assignments for')
    sub.add_argument('-r', '--reviewable', dest = 'only_reviewable',
        action = 'store_true',
        help = 'show only unreviewed assignments')
    sub.set_defaults(f = list_assignments, a = lambda args:
        [args.hit, args.only_reviewable])

    for command, fun, helpmsg in [
            ('approve', approve_assignments, 'approve an assignment'),
            ('reject', reject_assignments, 'reject an assignment'),
            ('unreject', unreject_assignments, 'approve a previously rejected assignment')]:
        sub = subs.add_parser(command, help = helpmsg)
        sub.add_argument('assignment', nargs = '+',
            help = 'ID of an assignment')
        sub.add_argument('-m', '--message', dest = 'message',
            metavar = 'TEXT',
            help = 'feedback message shown to workers')
        sub.set_defaults(f = fun, a = lambda args:
            [args.message, args.assignment])

    sub = subs.add_parser('bonus',
        help = 'give a worker a bonus')
    sub.add_argument('amount', type = float,
        help = 'bonus amount, in USD')
    sub.add_argument('message',
        help = 'the reason for the bonus (shown to workers in an email sent by MTurk)')
    sub.add_argument('widaid', nargs = '+',
        help = 'a WORKER_ID,ASSIGNMENT_ID pair')
    sub.set_defaults(f = grant_bonus, a = lambda args:
        [args.message, args.amount,
            [p.split(',') for p in args.widaid]])

    cmdline_args = parser.parse_args()
    init(cmdline_args.sandbox)
    f = cmdline_args.f
    a = cmdline_args.a(cmdline_args)
    if isinstance(a, dict):
        # We do some introspective gymnastics so we can produce a
        # less incomprehensible error message if some arguments
        # are missing.
        spec = inspect.getargspec(f)
        missing = set(spec.args[: len(spec.args) - len(spec.defaults)]) - set(a.keys())
        if missing:
            raise ValueError('Missing arguments: ' + ', '.join(missing))
        x = f(**a)
    else:
        x = f(*a)

    if x is not None:
        print x
